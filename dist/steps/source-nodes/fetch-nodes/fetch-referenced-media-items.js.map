{"version":3,"sources":["../../../../src/steps/source-nodes/fetch-nodes/fetch-referenced-media-items.js"],"names":["nodeFetchConcurrency","concurrency","Number","process","env","GATSBY_CONCURRENT_DOWNLOAD","adjustedConcurrency","normalizedConcurrency","mediaFileFetchQueue","PQueue","carryoverConcurrencyCount","mediaNodeFetchQueue","previouslyRetriedPromises","pushPromiseOntoRetryQueue","node","helpers","createContentDigest","actions","queue","retryKey","retryPromise","add","timesRetried","Promise","resolve","setTimeout","error","reporter","info","panic","createMediaItemNode","parentName","allMediaItemNodes","existingNode","getNode","id","store","dispatch","logger","incrementActivityTimer","typeName","by","push","resolveFutureNode","futureNode","mediaItemUrl","fetchTimeout","log","fileSize","pluginOptions","createFileNodes","type","MediaItem","localFileNode","mediaItemNode","clearTimeout","localFile","parent","internal","contentDigest","normalizedNode","nodeTypeName","createNode","urlToFileExtension","url","pathname","urlUtil","parse","fileExtension","path","extname","stripImageSizesFromUrl","imageSizesPattern","RegExp","urlWithoutSizes","replace","createScaledImageUrl","isAlreadyScaled","includes","scaledUrl","processAndDedupeImageUrls","urls","reduce","accumulator","strippedUrl","scaledStrippedUrl","fetchMediaItemsBySourceUrl","mediaItemUrls","selectionSet","builtFragments","processedMediaItemUrls","cachedMediaItemNodeIds","uncachedMediaItemUrls","previouslyCachedMediaItemNodes","all","map","nodeId","schema","perPage","mediaItemUrlsPages","length","allPromises","index","sourceUrls","entries","curPromise","join","query","sourceUrl","data","variables","first","after","errorContext","thisPagesNodes","Object","values","filter","Boolean","nodes","forEach","imageNodes","pushNodeMeta","modifiedGmt","onIdle","allResults","flat","fetchMediaItemsById","mediaItemIds","settings","typeInfo","newMediaItemIds","chunkedIds","relayIds","ids","split","slice","allNodesOfContentType","contentTypePlural","pluralName","nodesTypeName","in","throwFetchErrors","referencedMediaItemNodeIds","fetchReferencedMediaItemsAndCreateNodes","state","getState","queryInfo","remoteSchema","nodeQueries","mediaItems","gatsbyApi","createdNodes","nodesSourcedById","nodesSourcedByUrl"],"mappings":"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","sourcesContent":["import chunk from \"lodash/chunk\"\nimport store from \"~/store\"\nimport atob from \"atob\"\nimport filesize from \"filesize\"\nimport PQueue from \"p-queue\"\nimport { createLocalFileNode } from \"../create-nodes/create-local-file-node\"\nimport { paginatedWpNodeFetch, normalizeNode } from \"./fetch-nodes-paginated\"\nimport { buildTypeName } from \"~/steps/create-schema-customization/helpers\"\nimport fetchGraphql from \"~/utils/fetch-graphql\"\nimport { getFileNodeMetaBySourceUrl } from \"~/steps/source-nodes/create-nodes/create-local-file-node\"\nimport uniq from \"lodash/uniq\"\nimport urlUtil from \"url\"\nimport path from \"path\"\nimport { getPluginOptions } from \"~/utils/get-gatsby-api\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\n\nconst nodeFetchConcurrency = 2\n\nconst concurrency = Number(process.env.GATSBY_CONCURRENT_DOWNLOAD ?? 200)\nconst adjustedConcurrency = Number(concurrency ?? 200) - nodeFetchConcurrency\nconst normalizedConcurrency =\n  adjustedConcurrency <= nodeFetchConcurrency\n    ? concurrency\n    : adjustedConcurrency\n\nconst mediaFileFetchQueue = new PQueue({\n  concurrency: normalizedConcurrency,\n  carryoverConcurrencyCount: true,\n})\n\nconst mediaNodeFetchQueue = new PQueue({\n  concurrency: nodeFetchConcurrency,\n  carryoverConcurrencyCount: true,\n})\n\nconst previouslyRetriedPromises = {}\n\nconst pushPromiseOntoRetryQueue = ({\n  node,\n  helpers,\n  createContentDigest,\n  actions,\n  queue,\n  retryKey,\n  retryPromise,\n}) => {\n  queue.add(async () => {\n    const timesRetried = previouslyRetriedPromises[retryKey] || 0\n\n    if (timesRetried >= 2) {\n      // if we've retried this more than once, pause for a sec.\n      await new Promise(resolve =>\n        setTimeout(() => resolve(), timesRetried * 500)\n      )\n    }\n\n    try {\n      await retryPromise({\n        createContentDigest,\n        actions,\n        helpers,\n        node,\n        queue,\n        retryKey,\n        retryPromise,\n        timesRetried,\n      })\n    } catch (error) {\n      // Errors that should exit are handled one level down\n      // in createLocalFileNode\n      //\n      // if we haven't reqeued this before,\n      // add it to the end of the queue to\n      // try once more later\n      if (timesRetried < 5) {\n        if (timesRetried > 1) {\n          helpers.reporter.info(\n            `pushing ${retryKey} to the end of the request queue.`\n          )\n\n          helpers.reporter.info(\n            `Previously retried ${timesRetried} times already.`\n          )\n        }\n\n        previouslyRetriedPromises[retryKey] = timesRetried + 1\n\n        pushPromiseOntoRetryQueue({\n          node,\n          helpers,\n          createContentDigest,\n          actions,\n          queue,\n          retryKey,\n          retryPromise,\n        })\n      } else {\n        helpers.reporter.info(\n          `\\n\\nalready re-queued ${retryKey} 5 times :( sorry.\\nTry lowering process.env.GATSBY_CONCURRENT_DOWNLOAD.\\nIt's currently set to ${process.env.GATSBY_CONCURRENT_DOWNLOAD}\\n\\n`\n        )\n        // we already tried this earlier in the queue\n        // no choice but to give up :(\n        helpers.reporter.panic(error)\n      }\n    }\n  })\n}\n\nexport const createMediaItemNode = async ({\n  node,\n  helpers,\n  createContentDigest,\n  actions,\n  parentName,\n  allMediaItemNodes = [],\n}) => {\n  const existingNode = await helpers.getNode(node.id)\n\n  if (existingNode) {\n    return existingNode\n  }\n\n  store.dispatch.logger.incrementActivityTimer({\n    typeName: `MediaItem`,\n    by: 1,\n  })\n\n  allMediaItemNodes.push(node)\n\n  let resolveFutureNode\n  const futureNode = new Promise(resolve => {\n    resolveFutureNode = resolve\n  })\n\n  pushPromiseOntoRetryQueue({\n    node,\n    helpers,\n    createContentDigest,\n    actions,\n    queue: mediaFileFetchQueue,\n    retryKey: node.mediaItemUrl,\n    retryPromise: async ({\n      createContentDigest,\n      actions,\n      helpers,\n      node,\n      retryKey,\n      timesRetried,\n    }) => {\n      const fetchTimeout = setTimeout(() => {\n        helpers.reporter.log(\n          formatLogMessage(\n            `Fetching ${\n              node.mediaItemUrl\n            } is taking a long time time (longer than 15 seconds). This file is ${filesize(\n              node.fileSize\n            )}`\n          )\n        )\n      }, 15000)\n\n      const pluginOptions = getPluginOptions()\n\n      const { createFileNodes } = pluginOptions.type.MediaItem\n\n      const localFileNode = createFileNodes\n        ? await createLocalFileNode({\n            mediaItemNode: node,\n            helpers,\n            parentName,\n          })\n        : null\n\n      clearTimeout(fetchTimeout)\n\n      if (timesRetried > 1) {\n        helpers.reporter.info(\n          `Successfully fetched ${retryKey} after retrying ${timesRetried} times`\n        )\n      }\n\n      node = {\n        ...node,\n        localFile: {\n          id: localFileNode?.id,\n        },\n        parent: null,\n        internal: {\n          contentDigest: createContentDigest(node),\n          type: buildTypeName(`MediaItem`),\n        },\n      }\n\n      const normalizedNode = normalizeNode({ node, nodeTypeName: `MediaItem` })\n\n      await actions.createNode(normalizedNode)\n      return resolveFutureNode(node)\n    },\n  })\n\n  return futureNode\n}\n\nconst urlToFileExtension = url => {\n  const { pathname } = urlUtil.parse(url)\n\n  const fileExtension = path.extname(pathname)\n\n  return fileExtension\n}\n\nexport const stripImageSizesFromUrl = url => {\n  const fileExtension = urlToFileExtension(url)\n\n  const imageSizesPattern = new RegExp(\n    // eslint-disable-next-line no-useless-escape\n    `(?:[-_]([0-9]+)x([0-9]+))${fileExtension ? `\\.${fileExtension}` : ``}`\n  )\n\n  let urlWithoutSizes = url.replace(imageSizesPattern, ``)\n\n  if (urlWithoutSizes !== url && fileExtension) {\n    urlWithoutSizes = `${urlWithoutSizes}${fileExtension}`\n  }\n\n  return urlWithoutSizes\n}\n\nconst createScaledImageUrl = url => {\n  const fileExtension = urlToFileExtension(url)\n\n  const isAlreadyScaled = url.includes(`-scaled${fileExtension || ``}`)\n\n  if (isAlreadyScaled) {\n    return url\n  }\n\n  let scaledUrl\n\n  if (fileExtension) {\n    scaledUrl = url.replace(fileExtension, `-scaled${fileExtension}`)\n  } else {\n    scaledUrl = `${url}-scaled`\n  }\n\n  return scaledUrl\n}\n\n// takes an array of image urls and returns them + additional urls if\n// any of the provided image urls contain what appears to be an image resize signifier\n// for ex https://site.com/wp-content/uploads/01/your-image-500x1000.jpeg\n// that will add https://site.com/wp-content/uploads/01/your-image.jpeg to the array\n// this is necessary because we can only get image nodes by the full source url.\n// simply removing image resize signifiers from all urls would be a mistake since\n// someone could upload a full-size image that contains that pattern - so the full\n// size url would have 500x1000 in it, and removing it would make it so we can never\n// fetch this image node.\nconst processAndDedupeImageUrls = urls =>\n  uniq(\n    urls.reduce((accumulator, url) => {\n      const scaledUrl = createScaledImageUrl(url)\n      accumulator.push(scaledUrl)\n\n      const strippedUrl = stripImageSizesFromUrl(url)\n\n      // if the url had no image sizes, don't do anything special\n      if (strippedUrl === url) {\n        return accumulator\n      }\n\n      accumulator.push(strippedUrl)\n\n      const scaledStrippedUrl = createScaledImageUrl(strippedUrl)\n      accumulator.push(scaledStrippedUrl)\n\n      return accumulator\n    }, urls)\n  )\n\nexport const fetchMediaItemsBySourceUrl = async ({\n  mediaItemUrls,\n  selectionSet,\n  builtFragments,\n  createContentDigest,\n  actions,\n  helpers,\n  allMediaItemNodes = [],\n}) => {\n  const processedMediaItemUrls = processAndDedupeImageUrls(mediaItemUrls)\n\n  const { cachedMediaItemNodeIds, uncachedMediaItemUrls } =\n    processedMediaItemUrls.reduce(\n      (accumulator, url) => {\n        const { id } = getFileNodeMetaBySourceUrl(url) || {}\n\n        // if we have a cached image and we haven't already recorded this cached image\n        if (id && !accumulator.cachedMediaItemNodeIds.includes(id)) {\n          // save it\n          accumulator.cachedMediaItemNodeIds.push(id)\n        } else if (!id) {\n          // otherwise we need to fetch this media item by url\n          accumulator.uncachedMediaItemUrls.push(url)\n        }\n\n        return accumulator\n      },\n      { cachedMediaItemNodeIds: [], uncachedMediaItemUrls: [] }\n    )\n\n  // take our previously cached id's and get nodes for them\n  const previouslyCachedMediaItemNodes = await Promise.all(\n    cachedMediaItemNodeIds.map(async nodeId => helpers.getNode(nodeId))\n  )\n\n  const {\n    schema: { perPage },\n  } = getPluginOptions()\n\n  // chunk up all our uncached media items\n  const mediaItemUrlsPages = chunk(uncachedMediaItemUrls, perPage)\n\n  // since we're using an async queue, we need a way to know when it's finished\n  // we pass this resolve function into the queue function so it can let us\n  // know when it's finished\n\n  // we have no media items to fetch,\n  // so we need to resolve this promise\n  // otherwise it will never resolve below.\n  if (!mediaItemUrlsPages.length) {\n    return Promise.resolve([])\n  }\n\n  const allPromises = []\n  // for all the images we don't have cached, loop through and get them all\n  for (const [index, sourceUrls] of mediaItemUrlsPages.entries()) {\n    const curPromise = new Promise(resolve => {\n      pushPromiseOntoRetryQueue({\n        helpers,\n        createContentDigest,\n        actions,\n        queue: mediaNodeFetchQueue,\n        retryKey: `Media Item by sourceUrl query #${index}, digest: ${createContentDigest(\n          sourceUrls.join()\n        )}`,\n        retryPromise: async () => {\n          const query = /* GraphQL */ `\n            query MEDIA_ITEMS {\n              ${sourceUrls\n                .map(\n                  (sourceUrl, index) => /* GraphQL */ `\n                mediaItem__index_${index}: mediaItem(id: \"${sourceUrl}\", idType: SOURCE_URL) {\n                  ...MediaItemFragment\n                }\n              `\n                )\n                .join(` `)}\n            }\n\n            fragment MediaItemFragment on MediaItem {\n              ${selectionSet}\n            }\n\n            ${builtFragments || ``}\n          `\n\n          const { data } = await fetchGraphql({\n            query,\n            variables: {\n              first: perPage,\n              after: null,\n            },\n            errorContext: `Error occurred while fetching \"MediaItem\" nodes in inline html.`,\n          })\n\n          // since we're getting each media item on it's single node root field\n          // we just needs the values of each property in the response\n          // anything that returns null is because we tried to get the source url\n          // plus the source url minus resize patterns. So there will be nulls\n          // since only the full source url will return data\n          const thisPagesNodes = Object.values(data).filter(Boolean)\n\n          // take the WPGraphQL nodes we received and create Gatsby nodes out of them\n          const nodes = await Promise.all(\n            thisPagesNodes.map(node =>\n              createMediaItemNode({\n                node,\n                helpers,\n                createContentDigest,\n                actions,\n                allMediaItemNodes,\n                parentName: `Fetching referenced MediaItem nodes by sourceUrl`,\n              })\n            )\n          )\n\n          nodes.forEach((node, index) => {\n            if (!node) {\n              return\n            }\n\n            // this is how we're caching nodes we've previously fetched.\n            store.dispatch.imageNodes.pushNodeMeta({\n              id: node.localFile.id,\n              sourceUrl: sourceUrls[index],\n              modifiedGmt: node.modifiedGmt,\n            })\n          })\n\n          resolve(nodes)\n        },\n      })\n    })\n    allPromises.push(curPromise)\n  }\n\n  await mediaNodeFetchQueue.onIdle()\n  await mediaFileFetchQueue.onIdle()\n\n  const allResults = await Promise.all(allPromises)\n  return allResults.flat()\n}\n\nexport const fetchMediaItemsById = async ({\n  mediaItemIds,\n  settings,\n  url,\n  selectionSet,\n  builtFragments,\n  createContentDigest,\n  actions,\n  helpers,\n  typeInfo,\n}) => {\n  const newMediaItemIds = mediaItemIds.filter(id => !helpers.getNode(id))\n\n  const {\n    schema: { perPage },\n  } = getPluginOptions()\n\n  const chunkedIds = chunk(newMediaItemIds, perPage)\n\n  if (!newMediaItemIds.length) {\n    return Promise.resolve([])\n  }\n\n  const allMediaItemNodes = []\n  const allPromises = []\n\n  for (const [index, relayIds] of chunkedIds.entries()) {\n    const curPromise = new Promise(resolve => {\n      pushPromiseOntoRetryQueue({\n        helpers,\n        createContentDigest,\n        actions,\n        queue: mediaNodeFetchQueue,\n        retryKey: `Media Item query #${index}, digest: ${createContentDigest(\n          relayIds.join()\n        )}`,\n        retryPromise: async () => {\n          // relay id's are base64 encoded from strings like attachment:89381\n          // where 89381 is the id we want for our query\n          // so we split on the : and get the last item in the array, which is the id\n          // once we can get a list of media items by relay id's, we can remove atob\n          const ids = relayIds.map(id => atob(id).split(`:`).slice(-1)[0])\n\n          const query = `\n          query MEDIA_ITEMS($in: [ID]) {\n            mediaItems(first: ${perPage}, where:{ in: $in }) {\n              nodes {\n                ${selectionSet}\n              }\n            }\n          }\n\n          ${builtFragments || ``}\n        `\n          const allNodesOfContentType = await paginatedWpNodeFetch({\n            first: perPage,\n            contentTypePlural: typeInfo.pluralName,\n            nodeTypeName: typeInfo.nodesTypeName,\n            query,\n            url,\n            helpers,\n            settings,\n            in: ids,\n            // this allows us to retry-on-end-of-queue\n            throwFetchErrors: true,\n          })\n\n          const nodes = await Promise.all(\n            allNodesOfContentType.map(node =>\n              createMediaItemNode({\n                node,\n                helpers,\n                createContentDigest,\n                actions,\n                allMediaItemNodes,\n                referencedMediaItemNodeIds: mediaItemIds,\n                parentName: `Fetching referenced MediaItem nodes by id`,\n              })\n            )\n          )\n\n          resolve(nodes)\n        },\n      })\n    })\n    allPromises.push(curPromise)\n  }\n\n  await mediaNodeFetchQueue.onIdle()\n  await mediaFileFetchQueue.onIdle()\n\n  const allResults = await Promise.all(allPromises)\n  return allResults.flat()\n}\n\nexport default async function fetchReferencedMediaItemsAndCreateNodes({\n  referencedMediaItemNodeIds,\n  mediaItemUrls,\n}) {\n  const state = store.getState()\n  const queryInfo = state.remoteSchema.nodeQueries.mediaItems\n\n  const { helpers, pluginOptions } = state.gatsbyApi\n  const { createContentDigest, actions } = helpers\n  const { url } = pluginOptions\n  const { typeInfo, settings, selectionSet, builtFragments } = queryInfo\n\n  let createdNodes = []\n\n  if (referencedMediaItemNodeIds?.length) {\n    const nodesSourcedById = await fetchMediaItemsById({\n      mediaItemIds: referencedMediaItemNodeIds,\n      settings,\n      url,\n      selectionSet,\n      builtFragments,\n      createContentDigest,\n      actions,\n      helpers,\n      typeInfo,\n    })\n\n    createdNodes = nodesSourcedById\n  }\n\n  if (mediaItemUrls?.length) {\n    const nodesSourcedByUrl = await fetchMediaItemsBySourceUrl({\n      mediaItemUrls,\n      settings,\n      url,\n      selectionSet,\n      builtFragments,\n      createContentDigest,\n      actions,\n      helpers,\n      typeInfo,\n    })\n\n    createdNodes = [...createdNodes, ...nodesSourcedByUrl]\n  }\n\n  return createdNodes.filter(Boolean)\n}\n"],"file":"fetch-referenced-media-items.js"}